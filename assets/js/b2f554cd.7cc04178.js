"use strict";(self.webpackChunkkunai_doc=self.webpackChunkkunai_doc||[]).push([[1477],{10:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"new-io-uring-events","metadata":{"permalink":"/blog/new-io-uring-events","editUrl":"https://github.com/kunai-project/kunai-doc/tree/main/blog/2025-05-27-io-uring/index.md","source":"@site/blog/2025-05-27-io-uring/index.md","title":"Kunai VS io_uring","description":"Introduction","date":"2025-05-27T13:37:00.000Z","formattedDate":"May 27, 2025","tags":[{"label":"news","permalink":"/blog/tags/news"},{"label":"R&D","permalink":"/blog/tags/r-d"},{"label":"malware","permalink":"/blog/tags/malware"}],"readingTime":5.81,"hasTruncateMarker":true,"authors":[{"name":"Quentin Jerome","title":"Kunai Maintainer","url":"https://github.com/qjerome","imageURL":"https://github.com/qjerome.png","key":"quentin"}],"frontMatter":{"slug":"new-io-uring-events","title":"Kunai VS io_uring","authors":["quentin"],"tags":["news","R&D","malware"],"date":"2025-05-27T13:37"},"nextItem":{"title":"Enhancing Detection Engineering with Automated Malware Sandboxing","permalink":"/blog/2024/10/02/kunai-malware-sandboxing"}},"content":"## Introduction\\n\\n`io_uring` is a cutting-edge feature available in the Linux kernel since version 5.1. It revolutionizes input/output (I/O) operations by enabling asynchronous processing. By utilizing shared ring buffers between user space and the kernel, `io_uring` minimizes system calls and context switches, significantly reducing latency and improving throughput. This makes it ideal for high-performance applications such as databases, web servers, and real-time data processing systems. With support for a wide range of I/O operations and flexible polling mechanisms, `io_uring` offers unparalleled efficiency and scalability, making it a game-changer in I/O performance optimization.\\n\\nIn this blog post, we will explore how `io_uring` works, its security implications, and how tools like **Kunai** can monitor `io_uring` operations.\\n\\n\x3c!-- truncate --\x3e\\n\\n## How it Works\\n\\n1. **Setting Up Shared Memory Areas:**\\n\\n   A userland program sets up two shared memory areas with the Linux kernel:\\n   - The submission queue (SQ), where submission queue entries (SQEs) are written by the userland program.\\n   - The completion queue (CQ), where completion queue entries (CQEs) are written by the kernel.\\n\\n2. **Submitting SQEs:**\\n\\n   The program submits SQEs to request I/O operations without waiting for completion, allowing non-blocking I/O operations.\\n\\n3. **Polling the CQ:**\\n\\n   The program regularly polls the CQ to check for the completion of I/O operations submitted in the submission queue.\\n\\nThis mechanism allows userland programs to rely on non-blocking syscalls and perform other processing while the kernel works, enhancing asynchronous coding possibilities.\\n\\nHowever, the past has taught us that there is always a trade-off between features and security, which we will explore in the following sections.\\n\\n## I/O Uring Rootkit\\n\\nThis section discusses [curing](https://github.com/armosec/curing), a PoC `io_uring` rootkit released by Armo and described in this [blog post][curing-blog-post]. Curing is a rootkit that uses `io_uring` to perform tasks without using traditional syscalls, making it invisible to several security tools relying on traditional syscall monitoring.\\n\\nIn the [blog post][curing-blog-post], Armo did not test their rootkit against **Kunai**, and we were curious to see if it bypasses **Kunai** monitoring. Unfortunately, the result isn\'t in favor of **Kunai** as it ends up being completely blind to the **curing** rootkit. But admitting its weaknesses is part of the improvement process, so let\'s try to understand why **Kunai** fails at detecting `io_uring` operations.\\n\\n## Why Kunai Fails to Detect io_uring Operations\\n\\nAfter this failure, it was time to understand why **Kunai** fails to detect any `io_uring` activity. Examining the Linux kernel, we found that almost every `io_uring` operation is handled by a dedicated function, different from traditional system calls. This can be seen in the [6.12 source](https://elixir.bootlin.com/linux/v6.12/source/io_uring/opdef.c#L52) (latest LTS at the time of writing).\\n\\n```c\\n// This is the io_uring operation\\n[IORING_OP_READV] = {\\n    ...\\n    .async_size         = sizeof(struct io_async_rw),\\n    .prep           = io_prep_readv,\\n    .issue          = io_read, // Function handling I/O\\n},\\n```\\n\\nAll I/O operations submitted via `io_uring` are handled by functions starting with the prefix `io_`. If we take the example of [`io_read`](https://elixir.bootlin.com/linux/v6.12/source/io_uring/rw.c#L939), we observe that it is dedicated to the `io_uring` subsystem and shares little code with traditional syscalls. As a direct consequence, none of the kernel functions hooked by **Kunai** is reached during `io_uring` operations, explaining why we are missing `io_uring` activity. In addition, it seems pretty unrealistic to adapt existing **Kunai** probes to be attached to the `io_uring` subsystem functions.\\n\\nIn summary, **Kunai** fails to detect `io_uring` operations because they are handled by dedicated functions that do not interact with the kernel functions monitored by **Kunai**.\\n\\n## io_uring Auditing and Security in the Kernel\\n\\nWhile examining the Linux source code, I took the opportunity to review the current auditing and security measures around the `io_uring` stack in the Linux kernel. Even though these findings are not new, they are nonetheless concerning.\\n\\nTraditional syscalls benefit from broad auditing via auditd and security control via [Linux security modules hooks](https://elixir.bootlin.com/linux/v6.15/source/include/linux/security.h). However, the `io_uring` subsystem has minimal auditing and security capabilities.\\n\\nKernel built-in auditing (excluding external tools) allows auditd to monitor `io_uring` operations since [v5.16](https://elixir.bootlin.com/linux/v5.16/source/fs/io_uring.c#L6666).\\n\\nFor `io_uring` security control through LSM, only kernel [v6.15](https://elixir.bootlin.com/linux/v6.15/source/security/security.c#L6005) (latest version at the time of writing) can block `io_uring` operations without distinguishing the operation.\\n\\nIn summary:\\n\\n- **v5.1 to v5.16**: No built-in auditing or security control.\\n- **v5.16 to v6.15**: Only operation auditing via auditd.\\n- **v6.15 onwards**: LSM hook to block any `io_uring` operation.\\n\\nAdditionally, `io_uring` is known to expose a large attack surface, leading to several kernel exploitations. Consequently, `io_uring` is restricted in Android and disabled in ChromeOS, which might be the right approach to prevent vulnerabilities. If you too are concerned about `io_uring`, you may consider disabling it via the [io_uring_disabled](https://www.kernel.org/doc/html/latest/admin-guide/sysctl/kernel.html#io-uring-disabled) parameter.\\n\\n## Kunai\'s Solution\\n\\nIf you choose to continue running the `io_uring` stack, [this commit](https://github.com/kunai-project/kunai/commit/7331186b4ebd6ebb1a27153af80dfb62f537bb9a) allows monitoring `io_uring` operations since kernel **v5.4** (minimal version supported by **Kunai**).\\n\\nIn order to monitor `io_uring` activity, we developed a specific eBPF probe that we attach to a strategic kernel function depending on the kernel version:\\n\\n- **v5.1 to v5.4**: [`__io_submit_sqe`](https://elixir.bootlin.com/linux/v5.4/source/fs/io_uring.c#L2046)\\n- **v5.5 to 6.14**: [`io_issue_sqe`](https://elixir.bootlin.com/linux/v6.14/source/io_uring/io_uring.c#L1722)\\n\\nBy doing so, we are able to inspect any `io_uring` SQE and grab its [`io_uring_op`](https://elixir.bootlin.com/linux/v6.12/source/include/uapi/linux/io_uring.h#L203) representing the kind of operation this SQE must perform. We then expose this information in a brand new event `io_uring_sqe`.\\n\\n```json\\n{\\n  \\"data\\": {\\n    \\"ancestors\\": \\"/usr/lib/systemd/systemd|/usr/bin/login|/usr/bin/zsh|/usr/bin/bash|/usr/bin/xinit|/usr/bin/i3|/usr/bin/bash|/usr/bin/urxvt|/usr/bin/zsh\\",\\n    \\"command_line\\": \\"./io_uring /tmp/out.txt\\",\\n    \\"exe\\": {\\n      \\"path\\": \\"/bogus/path/io_uring\\"\\n    },\\n    \\"op\\": {\\n      \\"code\\": 23,\\n      \\"name\\": \\"IORING_OP_WRITE\\"\\n    }\\n  },\\n  \\"info\\": {\\n    \\"host\\": \\"...\\",\\n    \\"event\\": {\\n      \\"source\\": \\"kunai\\",\\n      \\"id\\": 100,\\n      \\"name\\": \\"io_uring_sqe\\",\\n      \\"uuid\\": \\"6ed7d734-1a64-9541-8c5f-cc587ed4f5e0\\",\\n      \\"batch\\": 9\\n    },\\n    \\"task\\": \\"...\\",\\n    \\"parent_task\\": \\"...\\",\\n    \\"utc_time\\": \\"2025-05-27T14:29:10.077239078Z\\"\\n  }\\n}\\n```\\n\\nThis event provides visibility on `io_uring` usage and can be used to identify programs using `io_ring` and detect potentially suspicious activities. However, it is important to remember that `io_uring` blocking (through LSM) cannot be used before kernel **v6.15**. Yet, one can leverage **Kunai** actions in response to such events to kill processes using `io_uring`, but this is not a reliable solution to prevent vulnerability exploitation as **Kunai** actions may not be triggered in time to prevent a successful execution of the exploit.\\n\\n## Conclusion\\n\\n`io_uring` represents a significant advancement in the Linux kernel\'s I/O capabilities, offering substantial performance benefits for applications requiring high throughput and low latency. However, its implementation also introduces new security challenges, as demonstrated by the difficulties in monitoring and securing `io_uring` operations.\\n\\nKey takeaways include:\\n\\n- **Performance Benefits**: `io_uring` significantly enhances I/O performance by reducing system call overhead and enabling asynchronous operations.\\n- **Security Concerns**: The unique handling of `io_uring` operations poses challenges for traditional security tools, necessitating updated approaches to monitoring and control.\\n- **Monitoring Solutions**: Tools like **Kunai** are evolving to provide visibility into `io_uring` operations, though blocking malicious activities remains a challenge.\\n- **Kernel-Level Controls**: Recent kernel versions have introduced auditing and security controls for `io_uring`, but these are still limited compared to traditional syscalls.\\n\\nFor those concerned about the security implications of `io_uring`, disabling it via the [`io_uring_disabled`](https://www.kernel.org/doc/html/latest/admin-guide/sysctl/kernel.html#io-uring-disabled) parameter may be a prudent measure. As the Linux kernel continues to evolve, it is crucial for developers and security professionals to stay informed about the latest developments in `io_uring` and adapt their strategies accordingly.\\n\\n[curing-blog-post]:https://www.armosec.io/blog/io_uring-rootkit-bypasses-linux-security/"},{"id":"/2024/10/02/kunai-malware-sandboxing","metadata":{"permalink":"/blog/2024/10/02/kunai-malware-sandboxing","editUrl":"https://github.com/kunai-project/kunai-doc/tree/main/blog/2024-10-02-kunai-malware-sandboxing/index.md","source":"@site/blog/2024-10-02-kunai-malware-sandboxing/index.md","title":"Enhancing Detection Engineering with Automated Malware Sandboxing","description":"In the complex field of incident response, effective training for Security Operations Center (SOC) operators is critical. One of the key challenges in SOC training is providing realistic, data-driven environments that accurately simulate the threats and incidents operators will face. Additionally, detection engineers need reliable and actionable data to create robust detection rules that align with real-world security monitoring systems. However, gathering and analyzing real-world malware samples, which is essential to this process, can be time-consuming and prone to errors when done manually.","date":"2024-10-02T00:00:00.000Z","formattedDate":"October 2, 2024","tags":[{"label":"detection-engineering","permalink":"/blog/tags/detection-engineering"},{"label":"malware","permalink":"/blog/tags/malware"},{"label":"sandbox","permalink":"/blog/tags/sandbox"}],"readingTime":4.58,"hasTruncateMarker":true,"authors":[{"name":"Quentin Jerome","title":"Kunai Maintainer","url":"https://github.com/qjerome","imageURL":"https://github.com/qjerome.png","key":"quentin"}],"frontMatter":{"title":"Enhancing Detection Engineering with Automated Malware Sandboxing","authors":["quentin"],"tags":["detection-engineering","malware","sandbox"]},"prevItem":{"title":"Kunai VS io_uring","permalink":"/blog/new-io-uring-events"},"nextItem":{"title":"Using your MISP IoC in Kunai","permalink":"/blog/2024/04/19/kunai-misp"}},"content":"In the complex field of incident response, effective training for Security Operations Center (SOC) operators is critical. One of the key challenges in SOC training is providing realistic, data-driven environments that accurately simulate the threats and incidents operators will face. Additionally, detection engineers need reliable and actionable data to create robust detection rules that align with real-world security monitoring systems. However, gathering and analyzing real-world malware samples, which is essential to this process, can be time-consuming and prone to errors when done manually.\\n\\n\x3c!-- truncate --\x3e\\n\\nIn this blog post, we introduce an approach to solving these challenges through automation. We explore how a Kunai-based sandbox can streamline the collection and analysis of malware samples, offering a practical solution.\\n\\nBy leveraging this sandbox infrastructure, the project opens up new opportunities for more efficient malware analysis while supporting a wide range of CPU architectures, including those specific to IoT and mobile devices.\\n\\n# The Need for Realistic Data\\n\\nOne prerequisite for offering cyber ranges or training solutions in the context of detection engineering and security monitoring is the collection of real-world malware samples. \\n\\nTo provide high-quality training and realistic experiences, these samples can be used as injects in various training scenarios or for testing detection rules.\\n\\nA common approach is to collect such data manually by running and monitoring malware samples, preferably in a confined environment such as a virtual machine (VM). However, this approach has several drawbacks: it lacks reproducibility under identical experimental conditions and involves repetitive, error-prone tasks (uploading files, running monitoring tools/malware samples, monitoring network traffic, conducting post-analysis, etc.). \\n\\nThus, this process is an ideal candidate for automation. Our first motivation for creating this new project is to address these challenges. Our second goal is to provide detection engineers with a reliable way to generate **actionable data** from malware samples.\\n\\n# The Concept of a Kunai-Based Sandbox\\n\\nMalware sample sandboxing is a frequent task performed at various stages of a security alert\'s lifecycle, from incident/malware triage to more detailed malware analysis. This task is typically supported by numerous tools, ranging from open-source options like [Cape Sandbox](https://github.com/kevoreilly/CAPEv2/) to paid alternatives like [Joe Sandbox](https://www.joesandbox.com/#windows), [VMRay](https://www.vmray.com/), or [Any Run](https://any.run/).\\n\\nWhile these solutions are excellent in many respects\u2014such as defeating anti-sandboxing techniques and providing deep insight into a sample\'s capabilities\u2014we believe they are not always the best tools for gathering actionable information for detection engineers. For many organizations, there is no direct mapping between the data collected from malware analysis platforms (sandboxes) and their monitoring systems. As a result, a task that should be simple\u2014building detection rules tailored to an organization\u2019s security monitoring tools\u2014can become challenging.\\n\\nTo solve this issue, we propose a simple yet powerful sandboxing infrastructure based on [QEMU](https://www.qemu.org/) for virtualization and [Kunai](https://github.com/kunai-project/kunai) for sample monitoring. This infrastructure can serve multiple purposes: analyzing malware samples using the same tools employed for detection and collecting data for use within the NGSOTI project.\\n\\n![](assets/sandbox-diagram.png)\\n\\n\\n# Project Status\\n\\nThe source code for the project is available in the [Kunai sandbox repository](https://github.com/kunai-project/sandbox/). Additionally, our under-construction open dataset, extracted using this sandbox, can be found at [NGSOTI malware dataset](https://helga.circl.lu/NGSOTI/malware-dataset).\\n\\nCurrently, the sandboxing system can run Linux malware samples within a virtual environment, monitor them using [Kunai](https://github.com/kunai-project/kunai), and capture the network traffic generated by the system. Another key feature of our sandbox is its support for multiple CPU architectures (currently **Intel 32/64bits** and **ARM 64bits**), enabling the analysis of a broader range of malware samples. We believe **ARM** achitecture support is crucial, as it can be used to analyze malware samples specific to **IoT** or **mobile** (phones, tablets, etc.) devices.\\n\\n# Limitations\\n\\nWhile our approach provides a great opportunity for detection engineers to obtain data that is directly usable for creating [Kunai-based](https://github.com/kunai-project/kunai) detection rules, we must remember that it does not achieve the same level of stealthiness as other sandboxing platforms, which often rely on custom hypervisors. Therefore, our approach should not be considered a replacement for dedicated sandboxing platforms but rather a complement that facilitates detection engineering-related tasks.\\n\\n# Conclusion\\n\\nThe NGSOTI project aims to bridge the gap between theoretical knowledge and practical skills for SOC operators by offering realistic, data-driven training experiences. By automating the collection and analysis of malware samples through the Kunai-based sandbox, we provide a straightforward, efficient, and repeatable method for detection engineers to generate actionable insights. This approach is not intended to replace traditional sandboxing but rather to complement it. With support for multiple CPU architectures, including those specific to IoT and mobile devices, the sandbox expands the possibilities for analyzing and generating data from a wider range of malware, enhancing the diversity of scenarios that NGSOTI can offer. As the project progresses, we look forward to further enriching the open dataset and continuing to develop solutions that address the evolving challenges in detection engineering.\\n\\n# References\\n\\n- [Kunai project - sandbox](https://github.com/kunai-project/sandbox)\\n- [NGSOTI - malware-dataset](https://helga.circl.lu/NGSOTI/malware-dataset)\\n\\n# Funding\\n\\nThe NGSOTI project is dedicated to training the next generation of Security Operation Center (SOC) operators, focusing on the human aspect of cybersecurity. It underscores the significance of providing SOC operators with the necessary skills and open-source tools to address challenges such as detection engineering, incident response, and threat intelligence analysis. Involving key partners such as CIRCL, Restena, Tenzir, and the University of Luxembourg, the project aims to establish a real operational infrastructure for practical training. This initiative integrates academic curricula with industry insights, offering hands-on experience in cyber ranges.\\n\\nNGSOTI is co-funded under Digital Europe Programme (DEP) via the ECCC (European cybersecurity competence network and competence centre)."},{"id":"/2024/04/19/kunai-misp","metadata":{"permalink":"/blog/2024/04/19/kunai-misp","editUrl":"https://github.com/kunai-project/kunai-doc/tree/main/blog/2024-04-19-kunai-misp/index.md","source":"@site/blog/2024-04-19-kunai-misp/index.md","title":"Using your MISP IoC in Kunai","description":"MISP is an open-source cyber-threat information sharing platform which has been adopted by many actors of the industry over the last years. Organizations usually use it to exchange information about their own IT\xa0security incidents or about their Cyber Threat Intelligence (CTI) activities. Therefore a MISP instance, well connected with other instances, can quickly become a real gold mine containing a massive amount of Indicators of Compromise (IoC). By essence IoC are very specific and can be used to quickly identify compromised systems. In this blog post we are going to detail how to easily use IoC stored in a MISP instance to configure Kunai for real time compromise detection.","date":"2024-04-19T00:00:00.000Z","formattedDate":"April 19, 2024","tags":[],"readingTime":8.315,"hasTruncateMarker":true,"authors":[],"frontMatter":{},"prevItem":{"title":"Enhancing Detection Engineering with Automated Malware Sandboxing","permalink":"/blog/2024/10/02/kunai-malware-sandboxing"},"nextItem":{"title":"BPFDoor case study","permalink":"/blog/bpf-door-case-study"}},"content":"[MISP](https://www.misp-project.org) is an **open-source** cyber-threat information sharing platform which has been adopted by many actors of the industry over the last years. Organizations usually use it to exchange information about their own IT\xa0security incidents or about their Cyber Threat Intelligence (CTI) activities. Therefore a **MISP** instance, well connected with other instances, can quickly become a real gold mine containing a massive amount of **Indicators of Compromise (IoC)**. By essence **IoC** are very specific and can be used to quickly identify compromised systems. In this blog post we are going to detail how to easily use **IoC** stored in a **MISP** instance to configure **Kunai** for real time compromise detection.\\n\\n\x3c!-- truncate --\x3e\\n\\n## Warm up\\n\\nThe first step to do  is to get familiar with the kind of events **Kunai** is able to monitor on your system. So please, take a quick read over the [events documentation](/docs/events), in order to better understand the following steps. Additionally, the reader may want to get familiar with the documentation explaining how to use the tool for [threat detection purposes](/docs/advanced/).\\n\\nFor those not having the time to go through the whole documentation, nothing beats a good example. So below one can find the example of an `execve_script` event generated **for every** script being executed on a system running **Kunai**.\\n\\n```json\\n{\\n  \\"data\\": {\\n    \\"ancestors\\": \\"/usr/lib/systemd/systemd|/usr/bin/login|/usr/bin/zsh|/usr/bin/bash|/usr/bin/xinit|/usr/bin/i3|/usr/bin/bash|/usr/bin/urxvt|/usr/bin/zsh|/usr/bin/bash\\",\\n    \\"parent_exe\\": \\"/usr/bin/bash\\",\\n    \\"command_line\\": \\"/bin/bash /tmp/tmp.msdKnvj7ax_kunai_test.sh\\",\\n    \\"exe\\": {\\n      \\"file\\": \\"/tmp/tmp.msdKnvj7ax_kunai_test.sh\\",\\n      \\"md5\\": \\"64b8185d28042ea96feb251e12fe632b\\",\\n      \\"sha1\\": \\"31683c67b020d90f02a42e43e7758184ef98c12f\\",\\n      \\"sha256\\": \\"cda81b42b75647daf6b70a626380c199fe665d721e63bfe34c96b65da0289627\\",\\n      \\"sha512\\": \\"63165b902db5242a01296b39c1d6f2995fde961e29d9470d1862ccde8e2c8a3083659bf5d9c0794bbca620f37c419baec3c1d1941333d37fb9ced795553d2e83\\",\\n      \\"size\\": 21\\n    },\\n    \\"interpreter\\": {\\n      \\"file\\": \\"/usr/bin/bash\\",\\n      \\"md5\\": \\"e742da46d05de5afca58a2abcba5343e\\",\\n      \\"sha1\\": \\"8d48bdcb10eb85a0bd80c34e13fc01c2f6776043\\",\\n      \\"sha256\\": \\"664428e8dd065099a20cb364bdc293dd8f787ef10b9454b64e127a197950a5d6\\",\\n      \\"sha512\\": \\"b4e6f555571636f02704271d3a40b8470d04447ca3aaad073818f4041d944533bfbca0d5586dc945a2de8033f8fd4123f4203219e9c7b97ebbc52acd340e598f\\",\\n      \\"size\\": 1112880\\n    }\\n  },\\n  \\"info\\": {\\n    \\"host\\": \\"...\\",\\n    \\"event\\": {\\n      \\"source\\": \\"kunai\\",\\n      \\"id\\": 2,\\n      \\"name\\": \\"execve_script\\",\\n      \\"uuid\\": \\"520487fc-020c-5569-ed88-38393e49a2d2\\",\\n      \\"batch\\": 32\\n    },\\n    \\"task\\": \\"...\\",\\n    \\"parent_task\\": \\"...\\",\\n    \\"utc_time\\": \\"2024-02-13T08:34:29.312127521Z\\"\\n  }\\n}\\n```\\n\\nAs you can see, every **Kunai** event is composed of fields of various types. Some of these types can directly be matched against **IoCs**, following this correspondence table:\\n\\n|     Kunai data types      | cover IoC type |\\n| :-----------------------: | :------------: |\\n|           path            | absolute path  |\\n| md5, sha1, sha256, sha512 |      hash      |\\n|       domain / fqdn       | domain / fqdn  |\\n|        IP address         |  IPv4 / IPv6   |\\n\\n\\nSo any field of **any Kunai event** having a type in the above table will be checked against the **IoCs** loaded in the tool. Now the only thing we have to do is to feed **Kunai** with data in the expected **IoC** format. The format is pretty basic, yet flexible - the tool simply expects a file containing **JSON** documents. One can find an example file below:\\n\\n```json\\n{\\"uuid\\": \\"81050c82-68a5-4130-a56d-a465c8337066\\", \\"source\\":\\"My MISP Instance\\", \\"value\\":\\"why.kunai.rocks\\"}\\n{\\"uuid\\": \\"dd19ecd1-8237-427a-9b1d-35ff7d17381f\\", \\"source\\":\\"My MISP Instance\\", \\"value\\":\\"kunai.rocks\\"}\\n```\\n\\nThe format is simple enough to accommodate any **IoC** feed and is easily scriptable. So one could even imagine the creation of such a file from an IP list found on the Internet.\\n\\nNow, the reader should have a good picture of the topic and we can walk through a small experiment to get a bit more familiar with **Kunai** and its **IoC** matching capabilities.\\n\\n## A Little Experiment\\n\\nLet\'s run **Kunai** without any arguments, merely taking care of redirecting its output:\\n\\n```bash\\nsudo kunai | tee /tmp/kunai.log\\n# if one has jq installed one can pipe kunai output to jq\\n# in order to get a prettier output\\nsudo kunai | jq \'.\' | tee /tmp/kunai.log\\n```\\n\\nYou should start seeing some events printed on the terminal. You can try generating some more activity by leaving **Kunai** to run in a corner and use your system as you are used to. You can then stop it using `Ctrl + c`. \\n\\nIf you inspect the logs in `/tmp/kunai.log`, you will most likely find a wealth of useful information, especially if you have security monitoring needs. However, you may also come to the conclusion that there is simply too much useless information for your specific needs. So one can use [filtering / detection rules](/docs/advanced/rule_configuration) to be very selective of the events (out of scope for this post) or use **IoC** matching, to only display events matching an **IoC**. So lets do the exact same experiment as previously, but taking a file containing **IoCs** as parameter.\\n\\nThe first thing you need to do is to copy the following content into a file, let\'s say `/tmp/kunai-iocs.json`:\\n\\n```json\\n{\\"uuid\\": \\"81050c82-68a5-4130-a56d-a465c8337066\\", \\"source\\":\\"My MISP Instance\\", \\"value\\":\\"why.kunai.rocks\\"}\\n{\\"uuid\\": \\"dd19ecd1-8237-427a-9b1d-35ff7d17381f\\", \\"source\\":\\"My MISP Instance\\", \\"value\\":\\"kunai.rocks\\"}\\n```\\n\\nOnce this is done, start **Kunai**, passing this **IoC file** in the command line:\\n\\n```bash\\nsudo kunai -i /tmp/kunai-iocs.json\\n```\\n\\nAnd now the magic happens! You won\'t see logs any longer, but don\'t worry it is absolutely normal. Under the hood, **Kunai** is analyzing all the events (as the ones you saw in previous experiments) but it will only display the ones matching **IoCs**. So try to generate some network traffic (use `dig`, `curl` ...) towards domain `why.kunai.rocks` and you should see some events popping up on your terminal. If you visit the website with your browser, make sure it **doesn\'t use DOH** or any **DNS** protocol different from the one running on port **53.**\\n\\nIf you did the experiment and managed to generate an event matching one of the **IoCs** configured, you may have seen that the generated events contains **additional information** about the **matching IoC** in the `.detection` section of the event.\\n\\n```json\\n{\\n  \\"data\\": {\\n    \\"ancestors\\": \\"/usr/lib/systemd/systemd|/usr/bin/login|/usr/bin/zsh|/usr/bin/bash|/usr/bin/xinit|/usr/bin/i3|/usr/bin/bash|/usr/bin/urxvt|/usr/bin/zsh\\",\\n    \\"command_line\\": \\"dig why.kunai.rocks\\",\\n    \\"exe\\": {\\n      \\"file\\": \\"/usr/bin/dig\\"\\n    },\\n    \\"query\\": \\"why.kunai.rocks\\",\\n    \\"proto\\": \\"udp\\",\\n    \\"response\\": \\"kunai-project.github.io\\",\\n    \\"dns_server\\": {\\n      \\"ip\\": \\"10.96.0.1\\",\\n      \\"port\\": 53,\\n      \\"public\\": false,\\n      \\"is_v6\\": false\\n    }\\n  },\\n  \\"detection\\": {\\n    \\"iocs\\": [\\n      \\"why.kunai.rocks\\"\\n    ],\\n    \\"severity\\": 10\\n  },\\n  \\"info\\": {\\n    \\"host\\": \\"...\\",\\n    \\"event\\": {\\n      \\"source\\": \\"kunai\\",\\n      \\"id\\": 61,\\n      \\"name\\": \\"dns_query\\",\\n      \\"uuid\\": \\"7cf3a92b-b8fd-9035-4ced-8ca216adbf32\\",\\n      \\"batch\\": 38\\n    },\\n    \\"task\\": \\"...\\",\\n    \\"parent_task\\": \\"...\\",\\n    \\"utc_time\\": \\"2024-04-18T09:34:31.887637287Z\\"\\n  }\\n}\\n```\\n\\nIn the above example, we see only one **IoC** under the `detection` section, however if several **IoCs** would match an event, all of them would be in the list. Things should be a bit more concrete for you now, so lets dive into how to automatically ingest **MISP IoCs** into **Kunai**.\\n## Getting MISP IoCs into Kunai\\n\\nThe only thing which is missing, in order to configure **Kunai** from a **MISP instance**, is a way to  extract **IoCs** and translate them into the expected format. If you have already played with [PyMISP](https://github.com/MISP/PyMISP), this is not something that should be too scary and if you have not, here is the good news: we have a script which does it for you.  You can find the script in question over at the [Kunai tools repository](https://github.com/kunai-project/tools) under the [misp](https://github.com/kunai-project/tools/tree/main/misp) directory. \\n\\nBefore going further, make sure you have all the modules required (check out [requirements.txt](https://github.com/kunai-project/tools/blob/main/requirements.txt) at repository root) by Python so that this script works. \\n\\nThe next step is to create a configuration file for the script, simply rename the example configuration into `config.toml` and edit it so that it contains the settings to connect to the desired **MISP** instance.\\n\\nIf you have fulfilled the previous steps, you can simply run the `misp-to-kunai.py` script and you should see your **MISP\'s attributes**  translated into **Kunai IoC format** flowing in your terminal. This script has some options to be more selective on the **IoC**s to pull, however we will not go through all of them and will let the reader explore them. The only option we will use is the `-o` to write **IoC**s into a file. We encourage you to use the `-o` option to write into a file rather than doing a pure shell redirect as **this option prevents IoC duplication**.\\n\\nIf you take a look at the output generated by `misp-to-kunai.py` you may have noticed that **IoCs** are not exactly in the same format as the one described previously. Indeed, those contain an additional field - it being the `event_uuid` field -, which encodes the **MISP Event UUID** that the **IoC** belongs to. Any additional field to the ones described above, is ignored by **Kunai**, making the **IoC** format fairly flexible. Thanks to this you can add as many fields as you want, for instance to bring contextual information along with the **IoC**. We thought this one would be useful to enrich the **IoC** file with additional context, in case you would wish to correlate back to a **MISP Event**.\\n\\nIt is now time to put everything together:\\n\\n```bash\\n# pull IoCs from MISP\xa0and store them in Kunai IoC format\\n./misp-to-kunai.py -o /tmp/kunai-misp-iocs.json\\n\\n# run Kunai and check all events happening on your\\n# system against MISP IoCs\\nsudo kunai -i /tmp/kunai-misp-iocs.json\\n```\\n\\nAs seen in the previous experiment, you should not see any event coming out of **Kunai** until one actually matches an **IoC** you\'ve just loaded. The easiest way to try and see if everything works as expected is to execute a `dig` command against a domain from the **IoC** list.\\n\\nYes, you went though this entire blog post just to end up typing two simple lines into a shell, but now you understand why you typed those and how all this works.\\n\\n## Final Words\\n\\nThis post aimed at being dense and straightforward, mostly to prevent you from giving up. While monitoring an infrastructure, **IoC** checking is mandatory, not to miss \\"known things\\". On the other hand, **IoC** do not offer too much flexibility in the sense they cannot be used to detect Tactics, Techniques and Procedures (TTP) used by attackers. So if you would like to go further on this topic, we encourage you to learn [how to configure Kunai with rules](/docs/advanced/rule_configuration).\\n\\nOn the Python script side, there are also some interesting options deserving exploration, especially if you are interested in turning it into a service.\\n\\nAll the tools presented here are **open-source**, so feel free to read the code, modify it and contribute to it even in the form of feedback or GitHub issues. This is how we can keep improving our projects and better fit the users\' needs.\\n\\nWe hope you learned useful things or at least that you enjoyed reading this article.\\n\\n## References\\n\\n[Kunai project on GitHub](https://github.com/kunai-project/)  \\n[Kunai documentation](/docs/quickstart)  \\n[Kunai tools](https://github.com/kunai-project/tools)  \\n[MISP](https://www.misp-project.org/)  \\n[PyMISP](https://github.com/MISP/PyMISP)"},{"id":"bpf-door-case-study","metadata":{"permalink":"/blog/bpf-door-case-study","editUrl":"https://github.com/kunai-project/kunai-doc/tree/main/blog/2023-11-02-bpf-door/index.md","source":"@site/blog/2023-11-02-bpf-door/index.md","title":"BPFDoor case study","description":"This blog post is meant to give an insight of how to use Kunai for detection engineering.","date":"2023-11-02T13:37:00.000Z","formattedDate":"November 2, 2023","tags":[{"label":"malware","permalink":"/blog/tags/malware"},{"label":"detection-engineering","permalink":"/blog/tags/detection-engineering"}],"readingTime":14.605,"hasTruncateMarker":true,"authors":[{"name":"Quentin Jerome","title":"Kunai Maintainer","url":"https://github.com/qjerome","imageURL":"https://github.com/qjerome.png","key":"quentin"}],"frontMatter":{"slug":"bpf-door-case-study","title":"BPFDoor case study","authors":["quentin"],"tags":["malware","detection-engineering"],"date":"2023-11-02T13:37"},"prevItem":{"title":"Using your MISP IoC in Kunai","permalink":"/blog/2024/04/19/kunai-misp"},"nextItem":{"title":"Announcing Kunai","permalink":"/blog/announcing-kunai"}},"content":"This blog post is meant to give an insight of how to use Kunai for detection engineering.\\n\\nFor those who didn\'t have the opportunity to attend the Kunai workshop at [Hack.lu 2023 edition](https://hack.lu) this is a way to catch up on a big part of what we have been doing during this session. For those who actually attended the workshop, you can take a read anyway because the post goes even more into the details, as we were limited in time.\\n\\n\x3c!-- truncate --\x3e\\n\\n## About the Sample Studied in this Post\\n\\n**BPFDoor** has been chosen for this case study as it has been described, when it got discovered, as something not trivial to detect. The difficulties to detect mostly being depicted as the fact that it uses BPF based packet filtering to implement a nice backdoor. I will not deep dive in the description of what this malware is doing and how it works. If you want to know more about those topics, please find a non-exhaustive list of related posts and documents about BPFDoor malware in [references section](#about-bpfdoor).\\n\\n<table>\\n  <tr>\\n    <td><b>Filename</b></td>\\n    <td>bpfdoor.mwr</td>\\n  </tr>\\n  <tr>\\n    <td><b>md5</b></td>\\n    <td>0017f7b913ce66e4d80f7e78cf830a2b</td>\\n  </tr>\\n  <tr>\\n    <td><b>sha1</b></td>\\n    <td>f1bf775746a5c882b9ec003617b2a70cf5a5b029</td>\\n  </tr>\\n  <tr>\\n    <td><b>sha256</b></td>\\n    <td>fa0defdabd9fd43fe2ef1ec33574ea1af1290bd3d763fdb2bed443f2bd996d73</td>\\n  </tr>\\n  <tr>\\n    <td><b>sha512</b></td>\\n    <td>ff5dd28ba3f5ce1f85f85fa9b65f9f30fbd300f2ca238cb2713da7077b7a0a8ff094cff4d7de9381726925abdd9ea065fa75ccd02fa5a816b71a6f91479363c1</td>\\n  </tr>\\n</table>\\n\\n## Experiment Description\\n\\nYou can find here after the methodology followed in order to make our experiment. This methodology is not specific to this sample, so it can be used to study any malware you want with **Kunai**.\\n\\n1. Run **Kunai** in such a way you capture the output (redirect output to file or configure output file)\\n2. Run malware\\n3. Interact with the malware if needed/possible\\n\\nFor the sake of simplicity, I\xa0have prepared everything for you. You can find the Kunai\'s output for this sample in the following file [bpfdoor.jsonl](./assets/bpfdoor.jsonl). To improve the readability of that file, it went through a step of filtering so that it contains only the events related to the sample.\\n\\n:::info re-doing the experiments yourself\\nIt is possible, but you have to known that the events in the file got generated with the latest git (under development) version of **Kunai**. Therefore, some events will be missing if you take the latest release (i.e. **0.1.0**).\\n:::\\n\\n:::tip running BPFDoor\\n* run the sample as priviledged user otherwise it won\'t work\\n* the malware checks if an instance already running (you can know that by inspecting the source code or **stracing** the process)\\n:::\\n\\n:::caution running malware must be done with care\\n* always do it in a dedicated machine (i.e. VM), preferably **isolated** from the Internet\\n* Linux container isolation is not enough (the kernel is shared between host and containers)\\n* it is always better to know a bit what to expect from the sample (i.e. make sure it does not exploit your hypervisor)\\n:::\\n\\n## The Suspicious Events\\n\\nThe aim of this analysis is not necessarily to understand exactly what the malware is doing, as it can be achieved by other means (sandboxing, strace ...). The goal is to identify actionable events, on which we can build efficient detection rules. \\n\\n:::tip suspicious events\\nThe notion of a suspicious event is sometimes universal, sometimes subjective and sometimes depends on the context. So you might find more/less events suspicious than me while you look at the logs. Anyway any detection rule built on top of those events should be tested before being put into production.\\n:::\\n\\n### The Story of a Weird Command Line\\n\\nThe first event which should really catch our attention is the following. We see that a binary `/tmp/bpfdoor.mwr`, which should be qualified as unknown in a real infection, runs a rather suspicious one-liner command line.\\n\\n```json\\n{\\n  \\"data\\": {\\n    \\"ancestors\\": \\"/usr/lib/systemd/systemd|/usr/sbin/sshd|/usr/sbin/sshd|/usr/sbin/sshd|/usr/bin/bash|/usr/bin/sudo|/usr/bin/su|/usr/bin/bash|/tmp/bpfdoor.mwr\\",\\n    \\"parent_exe\\": \\"/tmp/bpfdoor.mwr\\",\\n    \\"command_line\\": \\"sh -c /bin/rm -f /dev/shm/kdmtmpflush;/bin/cp ./bpfdoor.mwr /dev/shm/kdmtmpflush && /bin/chmod 755 /dev/shm/kdmtmpflush && /dev/shm/kdmtmpflush --init && /bin/rm -f /dev/shm/kdmtmpflush\\",\\n    \\"exe\\": {\\n      \\"file\\": \\"/usr/bin/dash\\",\\n      \\"md5\\": \\"1e6b1c887c59a315edb7eb9a315fc84c\\",\\n      \\"sha1\\": \\"803ffdb71aa236aa25009bef97db1b8ad0e3c62b\\",\\n      \\"sha256\\": \\"64e48365207d0c19008ba7d53d75c0de3fcd5a1590e4c40fc69c677663fedc20\\",\\n      \\"sha512\\": \\"0d261d7a8d615d080e20f1e1b294f168107dc2740da1a037d9519215e67e7a72dcc0f56c0006e5fdc04b7dbbd339171e9d2bf15f8e31f295d37aff499e1bc928\\",\\n      \\"size\\": 129816\\n    }\\n  },\\n  \\"info\\": {\\n    ...\\n    \\"event\\": {\\n      \\"source\\": \\"kunai\\",\\n      \\"id\\": 1,\\n      \\"name\\": \\"execve\\",\\n      \\"uuid\\": \\"8f2fab25-ef70-3898-b52e-da2eaca820cc\\",\\n      \\"batch\\": 27\\n    },\\n    ...\\n  }\\n}\\n```\\n\\nWe clearly understand from this command line that the sample is copying itself to `/dev/shm` with a new name, changes its permissions, executes the new file and deletes it straight after. What else do we need to trigger the alarm ? This is already a good start, so lets extract some ideas out of this and continue our journey.\\n\\n:::info /dev/shm\\nThis is usually a **tmpfs** (in memory) filesystem so files running from that place will not persist on disk. Copying itself there, before executing and deleting itself could be seen as an attempt to evade malware cleaning run by an AV or any protection software.\\n:::\\n\\n:::tip detection takeaways\\n* a command line with `cp`, `chmod`, `exec`, `rm` happening in this order might be considered as a suspicious one-liner\\n  * increase severity if `ancestors` contains a binary of a service exposed on the Internet\\n  * increase severity if `command_line` contains `/dev/shm`\\n:::\\n\\n### Not Leaving Traces is Suspicious\\n\\nThe next event looking suspicious is the following and is strongly linked to the previous one. As it is the execution of the malware after it copied itself into `/dev/shm`.\\n\\n```json\\n{\\n  \\"data\\": {\\n    \\"ancestors\\": \\"/usr/lib/systemd/systemd|/usr/sbin/sshd|/usr/sbin/sshd|/usr/sbin/sshd|/usr/bin/bash|/usr/bin/sudo|/usr/bin/su|/usr/bin/bash|/tmp/bpfdoor.mwr|/usr/bin/dash\\",\\n    \\"parent_exe\\": \\"/usr/bin/dash\\",\\n    \\"command_line\\": \\"/dev/shm/kdmtmpflush --init\\",\\n    \\"exe\\": {\\n      \\"file\\": \\"/dev/shm/kdmtmpflush\\",\\n      \\"md5\\": \\"\\",\\n      \\"sha1\\": \\"\\",\\n      \\"sha256\\": \\"\\",\\n      \\"sha512\\": \\"\\",\\n      \\"size\\": 0,\\n      \\"error\\": \\"file not found\\"\\n    }\\n  },\\n  \\"info\\": {\\n    ...\\n    \\"event\\": {\\n      \\"source\\": \\"kunai\\",\\n      \\"id\\": 1,\\n      \\"name\\": \\"execve\\",\\n      \\"uuid\\": \\"38789315-0485-9af9-f511-27fe97b21a1c\\",\\n      \\"batch\\": 43\\n    },\\n    ...\\n  }\\n}\\n```\\n\\nWhat makes that event suspicious is that **Kunai**, did not managed to compute hashing information out of the executable path. The reason for this is simple, and the event is self explanatory, the **file is not found**. As we have seen previously the malware deletes the file straight after the execution. This type of things (quickly modifying a file) after its execution races **Kunai**, and this is sad. I will not go into the technical details but this is not really something we can change. However, the important thing is that when such thing happens **Kunai** tells it to you. So even if some information is missing from that event, we can still use it as a reliable source of suspiciousness.\\n\\n:::tip detection takeaways\\n* a binary for which we could not compute hashing information is suspicious, it means the file got modified/deleted straight after its execution\\n* a binary running from `/dev/shm` with priviledged user\\n* a known bad hash (not directly applicable to this event but to any event containing hashing information)\\n:::\\n\\n### Changing its own Task Name\\n\\nThe next suspicious candidate is the malware changing its task name. It does it using the `prctl` syscall, passing the `PR_SET_NAME` option as a first argument.\\n\\n```json\\n{\\n  \\"data\\": {\\n    \\"exe\\": \\"/dev/shm/kdmtmpflush\\",\\n    \\"command_line\\": \\"/dev/shm/kdmtmpflush --init\\",\\n    \\"option\\": \\"PR_SET_NAME\\",\\n    \\"arg2\\": \\"0x605368\\",\\n    \\"arg3\\": \\"0x0\\",\\n    \\"arg4\\": \\"0x6e75722d646c6168\\",\\n    \\"arg5\\": \\"0x3\\",\\n    \\"success\\": true\\n  },\\n  \\"info\\": {\\n    ...\\n    \\"event\\": {\\n      \\"source\\": \\"kunai\\",\\n      \\"id\\": 7,\\n      \\"name\\": \\"prctl\\",\\n      \\"uuid\\": \\"c8be60da-fa83-4a6c-aa8a-cbf1d38f8520\\",\\n      \\"batch\\": 45\\n    },\\n    \\"task\\": {\\n      \\"name\\": \\"hald-runner\\", // this is the new task name\\n      \\"pid\\": 1747,\\n      \\"tgid\\": 1747,\\n      \\"guuid\\": \\"7d64f958-4500-0000-82bb-77d6d3060000\\",\\n      \\"uid\\": 0,\\n      \\"gid\\": 0,\\n      \\"namespaces\\": {\\n        \\"mnt\\": 4026531840\\n      },\\n      \\"flags\\": \\"0x00400000\\"\\n    },\\n    ...\\n  }\\n}\\n```\\n\\nChanging task name cannot be considered as suspicious per se, you would probably see a lot of processes cloning/forking, changing their task names. So we have to use a bit more the data of this event to identify whether it is suspicious or not. We can observe two suspicious things though:\\n* our good old `/dev/shm` friend being in executable path\\n* `hald-runner` being used as a new task name, this is clearly an attempt to mimic a legit process/service task name in order to fool people looking at running processes\\n\\n:::tip detection takeaways\\n* a binary located in `/dev/shm` changing its task name should raise an alert\\n* a task name being changed to mimic a legit binary\\n* it might be interesting to tag unknown (non whitelisted) binaries doing this and understand why they do so\\n:::\\n\\n### Attaching BPF Filter on a Raw Socket + Bonus\\n\\nFinally, the one we all expected and which gave its name to that malware ! We see that the executable is attaching a BPF\xa0filter to a raw socket `SOCK_RAW`.\\n\\n```json\\n{\\n  \\"data\\": {\\n    \\"command_line\\": \\"hald-runner\\",\\n    \\"exe\\": \\"/dev/shm/kdmtmpflush\\",\\n    \\"socket\\": {\\n      \\"domain\\": \\"AF_PACKET\\",\\n      \\"type\\": \\"SOCK_RAW\\"\\n    },\\n    \\"filter\\": {\\n      \\"md5\\": \\"19c9f9f52a7d7bf1f9c26dc57034873b\\",\\n      \\"sha1\\": \\"c97c5ad700f7426432dbe4d6478f362714e835f0\\",\\n      \\"sha256\\": \\"1a23f76646d1741946afd2d6d3ce3d0deae14198b544b09322a540c345953988\\",\\n      \\"sha512\\": \\"af9fce79e05316999ae3ef82ea7a04ce299c611cb46e27154e455b9f9bea42631a5293dd42cb0d332d5e10b8ed924930321cb3433b7989e6fe9042d97338d477\\",\\n      \\"len\\": 30,\\n      \\"size\\": 240\\n    },\\n    \\"attached\\": true\\n  },\\n  \\"info\\": {\\n    ...\\n    \\"event\\": {\\n      \\"source\\": \\"kunai\\",\\n      \\"id\\": 22,\\n      \\"name\\": \\"bpf_socket_filter\\",\\n      \\"uuid\\": \\"839aa10e-243a-3238-b221-9f7d0c1cac95\\",\\n      \\"batch\\": 51\\n    },\\n    \\"task\\": {\\n      \\"name\\": \\"hald-runner\\",\\n      \\"pid\\": 1748,\\n      \\"tgid\\": 1748,\\n      \\"guuid\\": \\"ff313459-4500-0000-82bb-77d6d4060000\\",\\n      \\"uid\\": 0,\\n      \\"gid\\": 0,\\n      \\"namespaces\\": {\\n        \\"mnt\\": 4026531840\\n      },\\n      \\"flags\\": \\"0x00400140\\"\\n    },\\n    \\"parent_task\\": {\\n      \\"name\\": \\"systemd\\", // this is init on this system\\n      \\"pid\\": 1,\\n      \\"tgid\\": 1,\\n      \\"guuid\\": \\"4b0dc405-0000-0000-82bb-77d601000000\\",\\n      \\"uid\\": 0,\\n      \\"gid\\": 0,\\n      \\"namespaces\\": {\\n        \\"mnt\\": 4026531840\\n      },\\n      \\"flags\\": \\"0x00400100\\"\\n    },\\n    \\"utc_time\\": \\"2023-09-05T09:33:07.600987330Z\\"\\n  }\\n}\\n```\\n\\nAttaching a BPF\xa0filter to a raw socket is definitely something suspicious ! But another thing interesting can be observed in this event. Our malware has suddently `systemd` as `parent_task`, while previously it was itself `hald-runner` (you have to look at the logs to verify that). So what the hell, happened ?\\n\\n:::info zombie process\\nA zombie process, is a process still running while it\'s parent is dead. When that happens the Linux Kernel makes the `init` process become the parent of the zombie process. Becoming a zombie is not something usually done on purpose as it is often the symptom of a bug. But if you are a malware you might use that trick to make people think your parent process is `init` binary (systemd in my case) and that you are a legitimate service.\\n:::\\n\\nSo this zombie process information is definitely something we can use to detect something strange is going on. In the log file, this event is the only one you will see with `systemd` as parent. This is because after that event the malware listen up for packets arriving on the raw socket. But don\'t worry, I\xa0can guarantee that any subsequent activity of this malware would have exactly the same anomaly and would give you even more opportunities to catch it.\\n\\n:::tip detection takeaways\\n* a binary attaching a BPF\xa0filter to a `SOCK_RAW`\\n* a binary attaching a BPF\xa0filter to a socket\\n  * increase severity if running in `/dev/shm`\\n  * increase severity if task name changed\\n    * increase severity if mimics a legit service\\n* any zombie process (parent_task became init pid=1)\\n  * increase severity if running in `/dev/shm` or unknown service binary\\n:::\\n\\n### Going Further, for Even More Detection Possibilities\\n\\nIf you looked at the logs, you have probably noticed that the [previous event](#attaching-bpf-filter-on-a-raw-socket--bonus) we described is one of the last interesting things we see. Afer, everything looks to cleanup events. This is not all with this malware at all, as you may have also observed that the task with pid 1748 didn\'t exit.\\n\\n```\\nroot@ebpf-ubuntu-20:/tmp# ps aux | grep 1748\\nroot        1748  0.0  0.0   2496    84 ?        Ss   Sep05   0:00 hald-runner\\n```\\n\\nThis is the task listening on the raw socket and waiting for commands. So the malware is still running and all we have analyzed so far are only the events generated when the malware is spawned on a system, we did not interact with the malware whatsoever. This is because I\xa0did not take the time to reverse-engineer the sample to know the password it expects when it receives packets on its raw socket. \\n\\n:::tip homework\\n* reverse the sample, find the key and send expected packets to the sample\\n* compile the malware from [sources][bpfdoor-src-code] (not guaranteed of being the exact same one) with a key you know and send packets to the sample\\n:::\\n\\nWhat we can see from the [BPFDoor sources][bpfdoor-src-code], is that we can expect even more detection possibilities:\\n\\n* the sample runs specific `iptables` commands\\n* it again changes task name, to `/usr/libexec/postfix/master`\\n* it can execute abitrary commands and very likely suspicious ones, which should not be ran from anything else than an interactive shell (`whoami`, `cat` ...). Programmers usually prefer using APIs rather than parsing shell outputs.\\n* we would see a binary located in `/dev/shm` communicating over the network\\n\\nAnother blind spot we have in this analysis is the original infection vector. I may have missed it but I\xa0didn\'t find this information online either. Anyway, what is important here is that knowing the infection vector would have been very likely an additional way to catch this sample. This is purely fictional but if we assume it went through a web server compromise, we would have seen at some point a `/dev/shm/kdmtmpflush` [execve event](/docs/events/execve) with a web server binary being in it\'s `ancestors` field.\\n\\n:::tip detection takeaways\\n* something executed from `/dev/shm` running commands\\n  * increase severity if running commands such as `iptables`, `whoami`, `cat`\\n* a binary using a shell to execute commands (might need some whitelisting)\\n* something running in `/dev/shm` communicating over the Internet\\n* any service that has an exposed port on the Internet executing an unexpected binary\\n:::\\n\\n### Bonus: Detecting the Mistakes made by BPFDoor Authors\\n\\nSomething I\xa0observed while running several times this BPFDoor sample is that it sometimes renames its task with something containing `/` (the Linux path separator). Such an example can be observed below. \\n\\n```json\\n{\\n  \\"data\\": {\\n    \\"exe\\": \\"/dev/shm/kdmtmpflush\\",\\n    \\"command_line\\": \\"/dev/shm/kdmtmpflush --init\\",\\n    \\"option\\": \\"PR_SET_NAME\\",\\n    \\"arg2\\": \\"0x605368\\",\\n    \\"arg3\\": \\"0x0\\",\\n    \\"arg4\\": \\"0x8\\",\\n    \\"arg5\\": \\"0x3\\",\\n    \\"success\\": true\\n  },\\n  \\"info\\": {\\n    ...\\n    \\"event\\": {\\n        ...\\n        \\"id\\": 7,\\n        \\"name\\": \\"prctl\\",\\n        ...\\n    },\\n    ...\\n    \\"task\\": {\\n      // new task name\\n      \\"name\\": \\"/usr/sbin/conso\\",\\n      ...\\n    },\\n    ...\\n}\\n```\\n\\nThis is even more obvious when looking at the [malware source code][bpfdoor-src-code], the name of the process is changed by randomly picking an entry in the following array.\\n\\n```c\\nchar *self[] = {\\n        \\"/sbin/udevd -d\\",\\n        \\"/sbin/mingetty /dev/tty7\\",\\n        \\"/usr/sbin/console-kit-daemon --no-daemon\\",\\n        \\"hald-addon-acpi: listening on acpi kernel interface /proc/acpi/event\\",\\n        \\"dbus-daemon --system\\",\\n        \\"hald-runner\\",\\n        \\"pickup -l -t fifo -u\\",\\n        \\"avahi-daemon: chroot helper\\",\\n        \\"/sbin/auditd -n\\",\\n        \\"/usr/lib/systemd/systemd-journald\\"\\n};\\n```\\n\\nThis caught my attention because this is not something you see very often in Linux and luckily for us there is a good explaination for that. The Linux Kernel, when performing execve it calls [begin_new_exec](https://elixir.bootlin.com/linux/latest/C/ident/begin_new_exec), itself calling [__set_task_comm(me, kbasename(bprm->filename), true)](https://elixir.bootlin.com/linux/latest/source/fs/exec.c#L1366). What it does is simple, `__set_task_comm` assigns the new task name with `kbasename(some_filename)`. And guess what, [kbasename](https://elixir.bootlin.com/linux/latest/C/ident/kbasename) is actually taking the [basename](https://en.wikipedia.org/wiki/Basename) out of a path.\\n\\n:::info\\ntask name is always **16 bytes** so any longer string is truncated. This is why in our event we see task name `/usr/sbin/conso`instead of `/usr/sbin/console-kit-daemon --no-daemon`\\n:::\\n\\nAll this to say that it should not be considered as normal to have a task name containing `/`. The `PR_SET_NAME` option of the prctl syscall is meant to change the task name. By convention (this is not enforced) task names does not contain any `/`. So it is not really a mis-use of the `prctl` syscall the malware authors did but they rather forgot/didn\'t know that Linux task name are not supposed to contain `/`. This anomaly could be used to detect such a bad programming practice, that I hope is seen only in malware !\\n\\n:::tip detection takeaways\\n* a task name containing `/` is abnormal (programming mistake)\\n* a task name not contained in the `exe` filename is suspicious for unknown binary. Some whitelisting would be needed as threaded programs often rename their threads with custom names.\\n:::\\n\\n## Conclusion\\n\\nAssuming we have Kunai running on our machine, would it be complicated to detect this kind of sample knowing what we know now ? I would say no as there are enough suspicious things we can rely on and which should not trigger that many false positives.\\n\\nThis is always easy to say that we can detect things a posteriori. In order to have a chance to catch such sample in the wild, relevant generic rules and eventually heuristics need to be built. This is why it is very important to make as much as possible this kind of exercise as it would help us filling the gaps in detection rules. Sorry for all the guys who think they are protected because they bought an expensive commercial solution but you\'d have to do this kind of work too, especially if you are a valuable target to attackers. I will not argue for hours about this but the main argument is that commercial solution are not bad per se, but they have to be generic enough to satisfy the more use cases as possible. Satisfying use cases is usually synonym of not having too many false positives, at the cost of discarding some true positives under some very specific/targetted environment. So if you have a commercial solution, do this job and enrich your detection rules, it won\'t be lost and you will probably make one of your engineers happy to use his brain.\\n\\nIn the reports, everyone tends to agree on one thing: this kind of malware is difficult to detect. Is it a question of stealthiness of the malware ? I\xa0don\'t think so, because we have seen it does a lot of very suspicious things, and we can expect many others (we did not interact with the shell). I rather think the issue is the lack of visibility most of the people have, at least those who cannot afford an EDR. So according to this absolutely impartial argument, it gives you a very good reason to use **Kunai**.\\n\\nHappy Threat Detection and Hunting\\n\\n## References\\n\\n### About BPFDoor\\n* [Source code (probably not exactly the same one)][bpfdoor-src-code]\\n* https://www.countercraftsec.com/blog/a-step-by-step-bpfdoor-compromise/\\n* https://exatrack.com/public/Tricephalic_Hellkeeper.pdf\\n* https://www.trendmicro.com/en_us/research/23/g/detecting-bpfdoor-backdoor-variants-abusing-bpf-filters.html\\n\\n[bpfdoor-src-code]: https://github.com/gwillgues/BPFDoor/blob/main/bpfdoor.c"},{"id":"announcing-kunai","metadata":{"permalink":"/blog/announcing-kunai","editUrl":"https://github.com/kunai-project/kunai-doc/tree/main/blog/2023-06-23-announcing-kunai/index.md","source":"@site/blog/2023-06-23-announcing-kunai/index.md","title":"Announcing Kunai","description":"Why Kunai","date":"2023-06-23T00:00:00.000Z","formattedDate":"June 23, 2023","tags":[{"label":"announcement","permalink":"/blog/tags/announcement"}],"readingTime":0.045,"hasTruncateMarker":false,"authors":[{"name":"Quentin Jerome","title":"Kunai Maintainer","url":"https://github.com/qjerome","imageURL":"https://github.com/qjerome.png","key":"quentin"}],"frontMatter":{"slug":"announcing-kunai","title":"Announcing Kunai","authors":["quentin"],"tags":["announcement"]},"prevItem":{"title":"BPFDoor case study","permalink":"/blog/bpf-door-case-study"}},"content":"## Why Kunai\\n\\nBecause you guys are ninjas !"}]}')}}]);