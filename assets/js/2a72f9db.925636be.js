"use strict";(self.webpackChunkkunai_doc=self.webpackChunkkunai_doc||[]).push([[3550],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>g});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),u=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=u(e.components);return i.createElement(l.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},m=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),c=u(n),m=a,g=c["".concat(l,".").concat(m)]||c[m]||d[m]||r;return n?i.createElement(g,o(o({ref:t},p),{},{components:n})):i.createElement(g,o({ref:t},p))}));function g(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:a,o[1]=s;for(var u=2;u<r;u++)o[u]=n[u];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}m.displayName="MDXCreateElement"},1292:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>u});var i=n(7462),a=(n(7294),n(3905));const r={slug:"new-io-uring-events",title:"Kunai VS io_uring",authors:["quentin"],tags:["news","R&D","malware"],date:"2025-05-27T13:37"},o="Kunai VS io_uring",s={permalink:"/blog/new-io-uring-events",editUrl:"https://github.com/kunai-project/kunai-doc/tree/main/blog/2025-05-27-io-uring/index.md",source:"@site/blog/2025-05-27-io-uring/index.md",title:"Kunai VS io_uring",description:"Introduction",date:"2025-05-27T13:37:00.000Z",formattedDate:"May 27, 2025",tags:[{label:"news",permalink:"/blog/tags/news"},{label:"R&D",permalink:"/blog/tags/r-d"},{label:"malware",permalink:"/blog/tags/malware"}],readingTime:5.81,hasTruncateMarker:!0,authors:[{name:"Quentin Jerome",title:"Kunai Maintainer",url:"https://github.com/qjerome",imageURL:"https://github.com/qjerome.png",key:"quentin"}],frontMatter:{slug:"new-io-uring-events",title:"Kunai VS io_uring",authors:["quentin"],tags:["news","R&D","malware"],date:"2025-05-27T13:37"},nextItem:{title:"Enhancing Detection Engineering with Automated Malware Sandboxing",permalink:"/blog/2024/10/02/kunai-malware-sandboxing"}},l={authorsImageUrls:[void 0]},u=[{value:"Introduction",id:"introduction",level:2},{value:"How it Works",id:"how-it-works",level:2},{value:"I/O Uring Rootkit",id:"io-uring-rootkit",level:2},{value:"Why Kunai Fails to Detect io_uring Operations",id:"why-kunai-fails-to-detect-io_uring-operations",level:2},{value:"io_uring Auditing and Security in the Kernel",id:"io_uring-auditing-and-security-in-the-kernel",level:2},{value:"Kunai&#39;s Solution",id:"kunais-solution",level:2},{value:"Conclusion",id:"conclusion",level:2}],p={toc:u},c="wrapper";function d(e){let{components:t,...n}=e;return(0,a.kt)(c,(0,i.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"introduction"},"Introduction"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"io_uring")," is a cutting-edge feature available in the Linux kernel since version 5.1. It revolutionizes input/output (I/O) operations by enabling asynchronous processing. By utilizing shared ring buffers between user space and the kernel, ",(0,a.kt)("inlineCode",{parentName:"p"},"io_uring")," minimizes system calls and context switches, significantly reducing latency and improving throughput. This makes it ideal for high-performance applications such as databases, web servers, and real-time data processing systems. With support for a wide range of I/O operations and flexible polling mechanisms, ",(0,a.kt)("inlineCode",{parentName:"p"},"io_uring")," offers unparalleled efficiency and scalability, making it a game-changer in I/O performance optimization."),(0,a.kt)("p",null,"In this blog post, we will explore how ",(0,a.kt)("inlineCode",{parentName:"p"},"io_uring")," works, its security implications, and how tools like ",(0,a.kt)("strong",{parentName:"p"},"Kunai")," can monitor ",(0,a.kt)("inlineCode",{parentName:"p"},"io_uring")," operations."),(0,a.kt)("h2",{id:"how-it-works"},"How it Works"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Setting Up Shared Memory Areas:")),(0,a.kt)("p",{parentName:"li"},"A userland program sets up two shared memory areas with the Linux kernel:"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"The submission queue (SQ), where submission queue entries (SQEs) are written by the userland program."),(0,a.kt)("li",{parentName:"ul"},"The completion queue (CQ), where completion queue entries (CQEs) are written by the kernel."))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Submitting SQEs:")),(0,a.kt)("p",{parentName:"li"},"The program submits SQEs to request I/O operations without waiting for completion, allowing non-blocking I/O operations.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Polling the CQ:")),(0,a.kt)("p",{parentName:"li"},"The program regularly polls the CQ to check for the completion of I/O operations submitted in the submission queue."))),(0,a.kt)("p",null,"This mechanism allows userland programs to rely on non-blocking syscalls and perform other processing while the kernel works, enhancing asynchronous coding possibilities."),(0,a.kt)("p",null,"However, the past has taught us that there is always a trade-off between features and security, which we will explore in the following sections."),(0,a.kt)("h2",{id:"io-uring-rootkit"},"I/O Uring Rootkit"),(0,a.kt)("p",null,"This section discusses ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/armosec/curing"},"curing"),", a PoC ",(0,a.kt)("inlineCode",{parentName:"p"},"io_uring")," rootkit released by Armo and described in this ",(0,a.kt)("a",{parentName:"p",href:"https://www.armosec.io/blog/io_uring-rootkit-bypasses-linux-security/"},"blog post"),". Curing is a rootkit that uses ",(0,a.kt)("inlineCode",{parentName:"p"},"io_uring")," to perform tasks without using traditional syscalls, making it invisible to several security tools relying on traditional syscall monitoring."),(0,a.kt)("p",null,"In the ",(0,a.kt)("a",{parentName:"p",href:"https://www.armosec.io/blog/io_uring-rootkit-bypasses-linux-security/"},"blog post"),", Armo did not test their rootkit against ",(0,a.kt)("strong",{parentName:"p"},"Kunai"),", and we were curious to see if it bypasses ",(0,a.kt)("strong",{parentName:"p"},"Kunai")," monitoring. Unfortunately, the result isn't in favor of ",(0,a.kt)("strong",{parentName:"p"},"Kunai")," as it ends up being completely blind to the ",(0,a.kt)("strong",{parentName:"p"},"curing")," rootkit. But admitting its weaknesses is part of the improvement process, so let's try to understand why ",(0,a.kt)("strong",{parentName:"p"},"Kunai")," fails at detecting ",(0,a.kt)("inlineCode",{parentName:"p"},"io_uring")," operations."),(0,a.kt)("h2",{id:"why-kunai-fails-to-detect-io_uring-operations"},"Why Kunai Fails to Detect io_uring Operations"),(0,a.kt)("p",null,"After this failure, it was time to understand why ",(0,a.kt)("strong",{parentName:"p"},"Kunai")," fails to detect any ",(0,a.kt)("inlineCode",{parentName:"p"},"io_uring")," activity. Examining the Linux kernel, we found that almost every ",(0,a.kt)("inlineCode",{parentName:"p"},"io_uring")," operation is handled by a dedicated function, different from traditional system calls. This can be seen in the ",(0,a.kt)("a",{parentName:"p",href:"https://elixir.bootlin.com/linux/v6.12/source/io_uring/opdef.c#L52"},"6.12 source")," (latest LTS at the time of writing)."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"// This is the io_uring operation\n[IORING_OP_READV] = {\n    ...\n    .async_size         = sizeof(struct io_async_rw),\n    .prep           = io_prep_readv,\n    .issue          = io_read, // Function handling I/O\n},\n")),(0,a.kt)("p",null,"All I/O operations submitted via ",(0,a.kt)("inlineCode",{parentName:"p"},"io_uring")," are handled by functions starting with the prefix ",(0,a.kt)("inlineCode",{parentName:"p"},"io_"),". If we take the example of ",(0,a.kt)("a",{parentName:"p",href:"https://elixir.bootlin.com/linux/v6.12/source/io_uring/rw.c#L939"},(0,a.kt)("inlineCode",{parentName:"a"},"io_read")),", we observe that it is dedicated to the ",(0,a.kt)("inlineCode",{parentName:"p"},"io_uring")," subsystem and shares little code with traditional syscalls. As a direct consequence, none of the kernel functions hooked by ",(0,a.kt)("strong",{parentName:"p"},"Kunai")," is reached during ",(0,a.kt)("inlineCode",{parentName:"p"},"io_uring")," operations, explaining why we are missing ",(0,a.kt)("inlineCode",{parentName:"p"},"io_uring")," activity. In addition, it seems pretty unrealistic to adapt existing ",(0,a.kt)("strong",{parentName:"p"},"Kunai")," probes to be attached to the ",(0,a.kt)("inlineCode",{parentName:"p"},"io_uring")," subsystem functions."),(0,a.kt)("p",null,"In summary, ",(0,a.kt)("strong",{parentName:"p"},"Kunai")," fails to detect ",(0,a.kt)("inlineCode",{parentName:"p"},"io_uring")," operations because they are handled by dedicated functions that do not interact with the kernel functions monitored by ",(0,a.kt)("strong",{parentName:"p"},"Kunai"),"."),(0,a.kt)("h2",{id:"io_uring-auditing-and-security-in-the-kernel"},"io_uring Auditing and Security in the Kernel"),(0,a.kt)("p",null,"While examining the Linux source code, I took the opportunity to review the current auditing and security measures around the ",(0,a.kt)("inlineCode",{parentName:"p"},"io_uring")," stack in the Linux kernel. Even though these findings are not new, they are nonetheless concerning."),(0,a.kt)("p",null,"Traditional syscalls benefit from broad auditing via auditd and security control via ",(0,a.kt)("a",{parentName:"p",href:"https://elixir.bootlin.com/linux/v6.15/source/include/linux/security.h"},"Linux security modules hooks"),". However, the ",(0,a.kt)("inlineCode",{parentName:"p"},"io_uring")," subsystem has minimal auditing and security capabilities."),(0,a.kt)("p",null,"Kernel built-in auditing (excluding external tools) allows auditd to monitor ",(0,a.kt)("inlineCode",{parentName:"p"},"io_uring")," operations since ",(0,a.kt)("a",{parentName:"p",href:"https://elixir.bootlin.com/linux/v5.16/source/fs/io_uring.c#L6666"},"v5.16"),"."),(0,a.kt)("p",null,"For ",(0,a.kt)("inlineCode",{parentName:"p"},"io_uring")," security control through LSM, only kernel ",(0,a.kt)("a",{parentName:"p",href:"https://elixir.bootlin.com/linux/v6.15/source/security/security.c#L6005"},"v6.15")," (latest version at the time of writing) can block ",(0,a.kt)("inlineCode",{parentName:"p"},"io_uring")," operations without distinguishing the operation."),(0,a.kt)("p",null,"In summary:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"v5.1 to v5.16"),": No built-in auditing or security control."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"v5.16 to v6.15"),": Only operation auditing via auditd."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"v6.15 onwards"),": LSM hook to block any ",(0,a.kt)("inlineCode",{parentName:"li"},"io_uring")," operation.")),(0,a.kt)("p",null,"Additionally, ",(0,a.kt)("inlineCode",{parentName:"p"},"io_uring")," is known to expose a large attack surface, leading to several kernel exploitations. Consequently, ",(0,a.kt)("inlineCode",{parentName:"p"},"io_uring")," is restricted in Android and disabled in ChromeOS, which might be the right approach to prevent vulnerabilities. If you too are concerned about ",(0,a.kt)("inlineCode",{parentName:"p"},"io_uring"),", you may consider disabling it via the ",(0,a.kt)("a",{parentName:"p",href:"https://www.kernel.org/doc/html/latest/admin-guide/sysctl/kernel.html#io-uring-disabled"},"io_uring_disabled")," parameter."),(0,a.kt)("h2",{id:"kunais-solution"},"Kunai's Solution"),(0,a.kt)("p",null,"If you choose to continue running the ",(0,a.kt)("inlineCode",{parentName:"p"},"io_uring")," stack, ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/kunai-project/kunai/commit/7331186b4ebd6ebb1a27153af80dfb62f537bb9a"},"this commit")," allows monitoring ",(0,a.kt)("inlineCode",{parentName:"p"},"io_uring")," operations since kernel ",(0,a.kt)("strong",{parentName:"p"},"v5.4")," (minimal version supported by ",(0,a.kt)("strong",{parentName:"p"},"Kunai"),")."),(0,a.kt)("p",null,"In order to monitor ",(0,a.kt)("inlineCode",{parentName:"p"},"io_uring")," activity, we developed a specific eBPF probe that we attach to a strategic kernel function depending on the kernel version:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"v5.1 to v5.4"),": ",(0,a.kt)("a",{parentName:"li",href:"https://elixir.bootlin.com/linux/v5.4/source/fs/io_uring.c#L2046"},(0,a.kt)("inlineCode",{parentName:"a"},"__io_submit_sqe"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"v5.5 to 6.14"),": ",(0,a.kt)("a",{parentName:"li",href:"https://elixir.bootlin.com/linux/v6.14/source/io_uring/io_uring.c#L1722"},(0,a.kt)("inlineCode",{parentName:"a"},"io_issue_sqe")))),(0,a.kt)("p",null,"By doing so, we are able to inspect any ",(0,a.kt)("inlineCode",{parentName:"p"},"io_uring")," SQE and grab its ",(0,a.kt)("a",{parentName:"p",href:"https://elixir.bootlin.com/linux/v6.12/source/include/uapi/linux/io_uring.h#L203"},(0,a.kt)("inlineCode",{parentName:"a"},"io_uring_op"))," representing the kind of operation this SQE must perform. We then expose this information in a brand new event ",(0,a.kt)("inlineCode",{parentName:"p"},"io_uring_sqe"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "data": {\n    "ancestors": "/usr/lib/systemd/systemd|/usr/bin/login|/usr/bin/zsh|/usr/bin/bash|/usr/bin/xinit|/usr/bin/i3|/usr/bin/bash|/usr/bin/urxvt|/usr/bin/zsh",\n    "command_line": "./io_uring /tmp/out.txt",\n    "exe": {\n      "path": "/bogus/path/io_uring"\n    },\n    "op": {\n      "code": 23,\n      "name": "IORING_OP_WRITE"\n    }\n  },\n  "info": {\n    "host": "...",\n    "event": {\n      "source": "kunai",\n      "id": 100,\n      "name": "io_uring_sqe",\n      "uuid": "6ed7d734-1a64-9541-8c5f-cc587ed4f5e0",\n      "batch": 9\n    },\n    "task": "...",\n    "parent_task": "...",\n    "utc_time": "2025-05-27T14:29:10.077239078Z"\n  }\n}\n')),(0,a.kt)("p",null,"This event provides visibility on ",(0,a.kt)("inlineCode",{parentName:"p"},"io_uring")," usage and can be used to identify programs using ",(0,a.kt)("inlineCode",{parentName:"p"},"io_ring")," and detect potentially suspicious activities. However, it is important to remember that ",(0,a.kt)("inlineCode",{parentName:"p"},"io_uring")," blocking (through LSM) cannot be used before kernel ",(0,a.kt)("strong",{parentName:"p"},"v6.15"),". Yet, one can leverage ",(0,a.kt)("strong",{parentName:"p"},"Kunai")," actions in response to such events to kill processes using ",(0,a.kt)("inlineCode",{parentName:"p"},"io_uring"),", but this is not a reliable solution to prevent vulnerability exploitation as ",(0,a.kt)("strong",{parentName:"p"},"Kunai")," actions may not be triggered in time to prevent a successful execution of the exploit."),(0,a.kt)("h2",{id:"conclusion"},"Conclusion"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"io_uring")," represents a significant advancement in the Linux kernel's I/O capabilities, offering substantial performance benefits for applications requiring high throughput and low latency. However, its implementation also introduces new security challenges, as demonstrated by the difficulties in monitoring and securing ",(0,a.kt)("inlineCode",{parentName:"p"},"io_uring")," operations."),(0,a.kt)("p",null,"Key takeaways include:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Performance Benefits"),": ",(0,a.kt)("inlineCode",{parentName:"li"},"io_uring")," significantly enhances I/O performance by reducing system call overhead and enabling asynchronous operations."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Security Concerns"),": The unique handling of ",(0,a.kt)("inlineCode",{parentName:"li"},"io_uring")," operations poses challenges for traditional security tools, necessitating updated approaches to monitoring and control."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Monitoring Solutions"),": Tools like ",(0,a.kt)("strong",{parentName:"li"},"Kunai")," are evolving to provide visibility into ",(0,a.kt)("inlineCode",{parentName:"li"},"io_uring")," operations, though blocking malicious activities remains a challenge."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Kernel-Level Controls"),": Recent kernel versions have introduced auditing and security controls for ",(0,a.kt)("inlineCode",{parentName:"li"},"io_uring"),", but these are still limited compared to traditional syscalls.")),(0,a.kt)("p",null,"For those concerned about the security implications of ",(0,a.kt)("inlineCode",{parentName:"p"},"io_uring"),", disabling it via the ",(0,a.kt)("a",{parentName:"p",href:"https://www.kernel.org/doc/html/latest/admin-guide/sysctl/kernel.html#io-uring-disabled"},(0,a.kt)("inlineCode",{parentName:"a"},"io_uring_disabled"))," parameter may be a prudent measure. As the Linux kernel continues to evolve, it is crucial for developers and security professionals to stay informed about the latest developments in ",(0,a.kt)("inlineCode",{parentName:"p"},"io_uring")," and adapt their strategies accordingly."))}d.isMDXComponent=!0}}]);